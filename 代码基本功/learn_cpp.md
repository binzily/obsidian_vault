# 序

①==解决方案==（Solution）

定义：解决方案是一个==容器==，它包含一个或多个项目（Project）。你可以把它想象成一个大的“项目包”，里面可以包含多个不同的项目，它们相互协作，共同构建一个完整的应用程序。

作用：管理多个项目之间的关系，比如项目的启动顺序、配置和平台设置等。

②==项目==（Project）

定义：项目是解决方案中的一个独立单元，它包含了==构建一个特定应用程序或库所需的所有文件和设置==。

作用：定义了如何==编译和链接应用程序==，包括源代码、资源文件、依赖项等。

③==引用==（References）

定义：引用是项目之间共享代码的一种方式。当你==在一个项目中引用了另一个项目==，你可以在当前项目中使用被引用项目的代码和资源。

作用：实现代码重用和模块化。比如，如果你有一个共享的类库项目，你可以在多个应用程序项目中引用它。

④==外部依赖项==

定义：外部依赖项是指项目在==编译时需要==，但不包含在项目文件中的代码或资源。这可以是第三方库、系统库或其他项目。
作用：确保项目能够访问到它需要的所有资源，即使这些资源不在项目目录下。

⑤==头文件==

定义：头文件通常包含==函数声明、宏定义、类型定义==等，它们被用来在不同的源文件之间共享接口和类型信息。
作用：==允许开发者在不同的源文件中使用相同的函数和类型，而不需要重新定义它们==。

⑥==源文件==

定义：源文件包含了实际的代码实现，比如函数的实现、类的方法等。
作用：是程序的主体部分，包含了程序的逻辑和行为。

⑦==资源文件==

定义：资源文件包含了程序运行时需要的==非代码资源==，比如图像、图标、声音文件等。
作用：提供程序的用户界面元素和多媒体内容。

总结：解决方案是最大的容器，它包含了一个或多个项目。每个项目可以有自己的源文件、头文件和资源文件，这些文件定义了项目的代码和资源。==项目之间可以通过引用来共享代码和资源==，实现代码的重用。外部依赖项是项目在编译时需要的，但不直接包含在项目中的资源，它们可以是其他项目的输出，也可以是第三方库。==头文件通常被多个源文件引用==，以共享接口和类型信息。资源文件为程序提供了非代码资源，它们在程序运行时被访问。

# 1.基础语法

## 1.1指针

### 1.1.1 指针基础

==指针 = 内存地址==，一般说指针是指==指针变量==，指针会被分配==8==个字节（无论类型）

```c++
int *p; //声明时：*只是相当于标记，表示这是个指针变量
cout << p; //p是指针变量
cout << *p; //使用时：*表示取指针p执行内存区域的数据
```

  ==对于指针或变量，遵循声明即分配内存原则。==

### 1.1.2 指针运算

指针==加减==的结果，和指针指向内存区域的数据有关。

==数组对象本身，记录的是第一个元素的内存地址。==

### 1.1.3 动态内存分配

==静态内存分配==：c++自动分配内存，不会清理（main函数执行完了才清理）。

new用于申请并分配内存空间，并提供指向该空间的指针，==new的结果是得到一个指针==。

```
new type //申请普通变量空间
new type[] // 申请数组空间
```

delete仅用于new运算符申请的区域。

```
delete 指针 //删除普通变量空间
delete[] 指针 //删除数组空间
```

ex：

```c++
int *p = new int; //new申请4个字节的空间，空间地址给p
```

```c++
int *p = new int[5]; //new申请可以存放5个元素的int空间，共5×4=20个字节
p[0] = 1; //指针也可以用下标
*p = 1; //p指向数组的第0个元素

p[1] = 2;
*(p+1) = 2;

delete[] p;
```

### 1.1.4 指针补充

避免==指针悬挂==：不要轻易指针间赋值；一旦delete，确保这个区域内存真的没人用了。

常量指针有三类。

## 1.2 结构体

### 1.2.1 结构体基础

结构体变量是一个整体的包装，无法直接输出。

结构体中的成员通常被存储在==连续的内存区域==中，但是成员之间可能会有==填充==（padding），这是为了满足特定的对齐要求。==对齐==要求是由编译器和硬件平台决定的，通常是为了提高内存访问的效率。

对齐（Alignment）：每个成员的起始地址必须是该成员类型大小的整数倍。例如，如果一个成员是int类型（通常是4字节），它的起始地址必须是4的倍数。
填充（Padding）：为了满足对齐要求，编译器可能会在成员之间或结构体的末尾插入额外的未使用空间（填充字节）。

### 1.2.2 结构体数组指针

结构体ex：

```c++
struct student;
{
    string name;
    int age;
    string gender;
}
struct student arr[3]; //结构体数组对象的声明
arr[0] = {"周杰伦"，11，"男"}；
arr[0] = {"林俊杰"，13，"男"}；
arr[0] = {"蔡依林"，12，"女"}；
```

结构体指针ex：

```c++
struct student *p = new student {"林俊杰"，11，"男"}；
```

结构体指针数组ex：

```c++
struct student arr[] = {{"周杰伦"},{"林俊杰"},{"刘德华",12,"男"}};
student *p = arr[]; //指向已存在数组地址
cout << p[0].name <<endl;
cout << p[1].name <<endl;
cou << p[2].name <<endl;
```

```c++
struct *p = new student[3]{
    {"周杰伦"};
    {"林俊杰"};
    {"刘德华",13,"男"};
}
cout << p[0].name <<endl; //p是指针，p的0号元素是结构体，所以用.来访问name
cout << p[1].name <<endl;
cout << p[2].name <<endl;
delete[] p;
```

## 1.3 函数

### 1.3.1 三种传递参数方式

函数的==值传递==：实质上是赋值，对实际参数没有影响。

函数传入数组，由于数组实际上是第一个元素的地址，所以传入数组就是传入第一个元素的指针。传入数组一般附带长度，因为c++不检查数组边界。地址传递对实参有影响。

==引用==传参：引用创建后不能修改指向，本质是指针常量（指向不可修改）。综合值传递和地址传递，可以像普通变量那样操作，对实参有影响。

```c++
void switch_num(int &a,int &b)
{
    int tmp;
    tmp = a;
    a = b;
    b = tmp;
}
```

用动态内存管理可以规避局部变量。

==static==表示静态，可以修饰变量、函数、数组。

# 2.C++核心编程

## 2.1 内存四区

代码区，全局区，栈区，堆区

1）==栈==是一种遵循后进先出（LIFO）原则的内存区域，用于存储==局部变量、函数参数以及返回地址。==
每当一个函数被调用时，一个新的栈帧（stack frame）会被创建并压入栈顶，存储当前函数的局部变量和返回地址。
当函数返回时，它的栈帧会被弹出栈。

2）==堆==是用于动态内存分配的内存区域。它允许程序在运行时申请和释放内存。
堆内存的分配和回收通常通过new、delete进行管理。
堆内存的管理比栈更复杂，因为需要手动管理内存的申请和释放，容易出现内存泄漏和野指针。



## 2.2 引用

只能从栈区或者堆区引用



## 2.3 函数提高

==函数声明==告诉编译器我写了这个函数，但是不一定在main（）函数之前。

### 2.3.1 函数的默认参数

①默认参数右边应全都写默认参数；

②如果声明有默认参数，函数实现就不能有默认参数。

### 2.3.2 函数的占位参数





### 2.3.3 函数的重载

作用：函数名可以相同。

使用条件：同一个作用域；函数参数类型or个数or顺序不同。



```c++
void func(int &a) //int &a = 10 错误，因为引用要是一个合法的内存空间，要么是栈区要么是堆区，常量在全局区。
{
    print("int &a");
}
void func(const int &a)
{
    print("const int &a"); //编译器会创建一个temp = 10，然后const int &a = temp
}

int a = 10;
func(a); //调用第一个
func(10); //调用第二个
```

## 2.3 类和对象

### 2.3.1 封装

类中的属性和方法，我们==统一==称为  成员。

属性也成为 成员属性、成员变量；方法也叫成员函数。

```
class 类名
{
	//访问权限
	//属性：通常是变量。
	//行为：通常使用函数。
}
```

封装的意义：将属性和方法作为一个==整体==，表现事物；将属性和方法加以==权限==控制。



struct和class的区别：前者默认权限public，后者默认权限private。

struct在栈区，class在堆区。

### 2.3.2 对象的初始化和清理

#### 2.3.2.1 构造函数和析构函数。

子类继承父类，会调用子类==和==父类的构造函数。

```c++
//拷贝构造函数
Person(const Person& p) {
	age = p.age;
	cout << "拷贝构造函数!" << endl;
}
```

请看如下代码： 

```c++
class Student
{
public:
    string name;
    string number;
    char X;
    int year;
    Student(string,string,char,int);      //构造函数声明
    void xianshi(void);     //用于输出类成员的值
};

//成员函数定义，包括构造函数
Student::Student(string N,string n,char x,int y)    //利用构造函数给类的成员赋值
{
    name = N;
    number = n;
    X = x;
    year = y;
}
```

在C++中，==类定义和成员函数的实现是分开的==，**即使成员变量在类定义中出现在构造函数声明之后，构造函数的实现仍然可以访问这些成员变量，因为它们都属于同一个类。**

在类定义中，成员变量name、number、X和year被声明，这意味着它们在==整个类中都是可见==的，成员变量`name`、`number`、`X`和`year`在类中被声明后，它们就可以在类的任何成员函数中被访问，包括构造函数和析构函数。

构造函数Student(string, string, char, int)也在类定义中声明，但它的实现（定义）在类定义之外，在这个实现中，你可以使用类中的所有成员变量，无论它们在类定义中声明的顺序如何。



**重难点：**

当你将一个对象传递给一个引用参数时，实际上==并不会==调用对象的构造函数。引用参数的传递不同于对象的拷贝或移动，它仅仅是原始对象的一个别名。

==成员函数不存在类的储存空间里面。类意义上只放静态的。==

==引用==本质上是另一个变量的别名，它不拥有自己的内存空间，而是直接与它所引用的变量关联。

==指向对象的指针==，可以直接访问该对象的任何公共成员变量或方法。



对于

```c++
Base* b = &d; //d为派生类
```

`Base* b` 可以指向任何从 `Base` 派生出来的类的实例，包括 `Derived` 类。但是，当你通过 `Base* b` 指针调用成员函数或访问成员变量时，编译器只允许你访问那些在 `Base` 类中声明的成员，因为编译器在编译时只能看到 `Base` 类的接口。

C++程序通常由多个源文件组成，每个源文件都是一个独立的编译单元。编译器对每个编译单元单独编译，生成目标文件（.o或.obj文件）。

编译器在编译时只能看到`Base`类的接口，因为它在编译`Base`类时没有`Derived`类的具体信息。这是由于C++的编译和链接模型导致的，其中类声明和定义可能分布在不同的编译单元中，编译器只能根据当前编译单元中可用的信息来编译代码

**即使b指针指向的是Derived类的对象，通过Base类指针直接访问Derived类中新增的成员也是不允许的，因为这会违反封装和抽象的原则。**



**如果不是虚函数就在代码区取出函数运行，但是运行代码区的是没法运行时改成猫，如果是虚函数就指向表，而表是可以更改（覆盖）。派生类继承基类时会继承基类的所有，包括虚函数，所以派生类要是想改这个功能的话就可以重写派生类的虚函数来覆盖父类的虚函数。**



#### 2.3.2.2 深拷贝和浅拷贝

对象2要拷贝对象1，如果对象1在堆中new了一个空间，在基类的析构函数中delete了这个空间。浅拷贝对象2会把这个new的空间地址原封不动拷贝过来，而且栈有后进先出原则这个空间会被delete两次，是非法操作。所以需要手动在new一个空间来实现深拷贝。

### 2.3.3 this指针

`this` 指针总是指向它所属的当前对象。

所以return *this 解引用，返回它所指向的对象。

```c++
Person& PersonAddPerson(Person& p)
	{
		this->age += p.age;

		return *this;
	}；
```

```c++
Person PersonAddPerson(Person& p)
	{
		this->age += p.age;

		return *this;
	}；
```

```c++
Person doWork(2)
{
	Person p1;
	return p1; //返回的不是p1本身，原来的p1被销毁了
}
```

前者`PersonAddPerson` 函数的返回类型是 `Person&`，意味着它返回一个对 `Person` 类型对象的引用。这个函数通过引用返回调用者（`*this`），这允许链式调用，因为返回的是对象的引用。

后者`PersonAddPerson` 函数的返回类型是 `Person`，意味着它返回一个 `Person` 类型的对象p2，而不是引用，即Person p2， 不加 & 返回时会调用拷贝构造函数 ，此时的返回值就是一个拷贝体 ，返回后会创建匿名对象，跟原来的p2不一样，因为原来的p2是个局部变量，会被销毁。表现在地址不一样，这样后面的.PersonAddAge就不会运行了   这样等于只运行了一次年龄加的操作 20。

写代码的时候最好形成一个规范，成员变量前加上==m_== , 表示member成员变量。

## 2.4 文件操作

 
